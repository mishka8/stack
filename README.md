# ОТЧЁТ
## Постановка задачи - Разбор алгебраического выражения с помощью стека
> [!NOTE]
> Множества
> 1. символов 'a'  - 'z', '0' - '9';
> 2. операций '+','-','*','/'  '(',')';

### РЕШЕНИЕ И АЛГОРИТМ
Так как наша задача проверить правильное ли выражение или нет, 
мы не учитываем приоритет операций.
Помещаем выражение в стек до тех пор пока не встретим вот такую скобку ')'.
Дальше мы проверяем всё то что лежит в скобках, меняем то что в скобках на новый символ.
После мы проверяем выражение которое осталось без скобок.

## СТЕК
> [!NOTE]
> Стек (от англ. stack — стопка) — структура данных, представляющая собой упорядоченный набор элементов, в которой добавление новых элементов и удаление существующих производится с одного конца, называемого вершиной стека.
```C
struct nodelist
{
    char inf;//данные 
    struct nodelist *next;//указатель на следующий элемент 
};
```

```C
struct Steklist
{
    struct nodelist *top;//верхушка
    int size;// количество элементов 
};
```
```C
typedef struct nodelist node;
typedef struct Steklist stek;
```
данные две строчки позволяют нам сделать новый тип данных в программе чтобы удобнее было писать код

### ФУНКЦИИ ДЛЯ РАБОТЫ СО СТЕКОМ

> [!NOTE]
> 1. push или положить в вершину
> 2. pop или вытащить из верщины
> 3. show top или показать вершину стека
> 4. print stek вывод стека
> 5. is empty проверка на пустоту
> 6. del stek удаление стека полностью

1. push или положить в вершину
```C
bool push(stek *st, char val)//входные данные стек и данные которые надо положить в стек
{
    if(st)//проверка что данные коректны
    {
        node *new_el = (node*) malloc(sizeof(node));// создаём элемент 
        if(new_el)// проверка что элемент создан
        {
            new_el -> inf = val;
            new_el -> next = NULL;
            if(st -> top == NULL) // если стек пуст 
            {
                st -> top = new_el; // новый элемент теперь вершина 
            }
            else
            {
                new_el -> next = st -> top; // проводим связи
                st -> top = new_el; // и объявляем неовый элемент вершиной стека
            }
            st -> size++; // увеличиваем количество значчений
            return true; // возвращаем true если функция отработала правильно 
        }
    }
    return false; //иначе возвращаем false
}
```
2. pop или вытащить из верщины
```C
char pop(stek *st)//входные данные стек 
{
    if(st)//проверка данных
    {
        if(st -> top)// проверка пуст ли стек или нет  
        {
            char elem = st -> top -> inf;// запоминаем элемент 
            node *ptrIx = st -> top;// делаем указатель на вершину стека 
            st -> top = st -> top -> next;// сдвигаем вершину стека 
            st -> size--;// уменьшаем размер 
            free(ptrIx);// удалем элемент 
            return elem;// возвращем элемент котрый запомнили 
        }
    }
    return 0;// иначе возвращаем ноль
}
```
3. show top или показать вершину стека
```C
bool ShowTop(stek *st, char *val)// входные данные стек и адрес куда положить данные из верха стека
{
    bool ans = false;// 
    if(st && val)// проверка данных 
    {
        if(st -> top)// если есть вершина стека
        {
            *val = st -> top -> inf;// кладём значение по адресу
            ans = true;// меняем ans на true
        }
    }
    return ans;// возвращаем ans
}
```
4. print stek вывод стека
```C
void print_stack(stek st)//входные данные стек
{
    if(st.top == NULL)// проверка если стека нет то стек пустой
        printf("Stack is empty!\n");
    node *current = st.top;// указатель для навигации по элементам 
    while(current)// 
    {
        printf("%c\n", current -> inf);  //вывод 
        current = current -> next;// указываем на следующий элемент 
    }
}
```
5. is empty проверка на пустоту
```C
bool isEmpty(stek st)//входные данные стек
{
    if(st.top == NULL)// если стек пустой 
        return true;// возвращаем true
    return false;// иначе возвращаем false
}
```

6. del stek удаление стека полностью
```C
void delStek(stek *st)//входные данные стек
{
    if(st)// проверка данных
    {
        if(st -> top)// проверка что есть вершина стека
        {
            node *ptr = st -> top;// указатель на вершину
            node *ptrIx = NULL;// указатель для удаления данных
            while(ptr)// 
            {
                ptrIx = ptr;// 
                ptr = ptr -> next;// уставнавливаем указатель на следующий элемент
                st -> size--;// уменьшаем размер
                free(ptrIx);// очищаем элемент
            }
            st -> top = NULL;//вершина теперь NULL
        }
    }
}
```
## ГЛАВНАЯ ФУНКЦИЯ ПРОВЕРКИ ВЫРАЖЕНИЯ

>[!IMPORTANT]
> 1. проверка данных
> 2. помещение символов в стек до символа ')'
> 3. проверка выражения в скобках и замена
> 4. проверка выражения которое осталось по итогу(без скобок)
> 5. и в конце проверка размера стека если ноль то выражение верно иначе не верно
```C
push(&st, 'v');
```

функйция проверки выражения без скобок 
```C
bool chek_triple(stek *st)//входные данные стек
{
    if(st == NULL)//проверка данных
        return false;
    int pos = 0;//позиция 
    while(isEmpty(*st) == false)//цикл пока наш стек не пустой 
    {
        char tmp = pop(st);
        if(gramar(tmp) || number(tmp))//проврка символа 
            if(pos % 2 != 0)// проверка позиции 
                return false;                    
        if(operation(tmp))//проверка знака 
            if(pos % 2 == 0)// проверка позиции 
                return false;
        pos++;
    }
    return true;
}
```



Сама функция: 
```C
bool check_expression(char *str)//входные данные строка
{
    if(str == NULL)//проверка данных
        return false;
        
    if(strlen(str) == 0)//проверка данных
        return false;
        
    if(operation(str[0]))//если первый символ операция то выражение неверное 
        return false;
        
    stek st = {NULL, 0};
    int i = 0;
    while(str[i])//цикл по строке
    {
        if(str[i] == '(')//проверка если между двумя скобками нчиего нет
            if(str[i + 1] && str[i + 1] == ')')//
                return false;
        
        if(str[i] == ')')//если находим закрывающую скобку 
        {
            if(str && str[i + 1] == '(')//проверка если дальше идёт скобка и между ними нет операции
                return false;
            char tmp;
            int pos = 0;//позиция 
            bool flag = true;
            while(flag)//цикл с помощью которого вытаскиваем и проверяем значения до '(' 
            {
                
                if(isEmpty(st))//проверка на пустоту 
                    return false;

                tmp = pop(&st); 
                pos++;
                
                char tmp_2;
                ShowTop(&st, &tmp_2);
                if(tmp_2 == '(')//проверка если следующее значение скобка
                    flag = false;//выходим из цикла
                
                if(gramar(tmp) || number(tmp))//проверка символа
                    if(pos % 2 == 0)//проверка позиции 
                        return false;
                
                if(operation(tmp))//проверка оператора 
                    if(pos % 2 == 1)//проверка позиции 
                        return false;
            }
            pop(&st);//достаём из стека '('
            push(&st, 'v');//и кладём новую перевменную которая заменяет выражение в скобках
        }
        
        else if(str[i] != ' ')//в стек заносим всё кроме пробелов 
        {
            
            if(i > 0 && str[i - 1] == '(' && (str[i] == '+' || str[i] == '-') && str[i + 2 ] && str[i+ 2] == ')')//проверка на унарные знаки 
                push(&st, '0');//если унарный сначала кладём ноль
            push(&st, str[i]);//кладём символ
            
        }    
        i++;//
    }
    if(chek_lexem(&st) == false)//проверка выражения которое осталось без скобок  
        return false;
    if(st.size == 0)//если размер стека равен нулю то программа отработала коректно 
        return true;
}
```

## ТЕСТИРОВКА ПРОГРАММЫ 
конечно же нам надо придумать тестировки для данной программы. Я придумал следующие тестировки 
```C
    //char str[size_str] = "";//uncorrect
    //char str[size_str] = "(()";//uncorrect
    //char str[size_str] = "(+h)";// correct
    //char str[size_str] = " (+2)";//correct
    //char str[size_str] = "(2 + (8 * a))";correct
    //char str[size_str] = "(2 (+ (8 )* a))";uncorrect
    //char str[size_str] = "(2) - (1)/(4(*3) ))";//uncorrect
    //char str[size_str] = "  (+2 - ((-1) / h ) + (a /  (-1)))";//correct
    //char str[size_str] = "((c-d)*h+1)*(a+b)";//correct
    //char str[size_str] = "(-d)";//correct
    //char str[size_str] = "f * a * 8 + 1 + a * ";//uncorrect
    //char str[size_str] = "f * a ++ a";//uncorrect
    //char str[size_str] = "-2 + (1)";//uncorrect
    //char str[size_str] = "(2 - 1 / (4/3))";//correct
    //char str[size_str] = "(+2)";//correct
    //char str[size_str] = "((c + d) * h + 1) * (a + b))))))))))))";//uncorrect
    //char str[size_str] = "(a+(b**h) - 8)";//uncorrect

    //char str[size_str] = "(-1) * (-2)";//correct
    //char str[size_str] = "(-1) * ()";//uuncorrect
    //char str[size_str] = "(-1)(-2)";//uncorrect
    //char str[size_str] = "(-1) * ()";//uncorrect
    //char str[size_str] = "(-1) * (+)";//uncorrect
```
Смотря на функцию проверки выражения, мы понимаем, что надо  проверить когда спрока пустая, когда строка состоит только из скобок, только из цифр, только буквы, где слишком много или слишком мало скобок, так же где символы стоят не на своих позициях,
где повторяющиеся символы, так же унарный плюс или унарный минус (Унарным называется оператор, который применяется к одному операнду), так же где совсем не мат операций.











