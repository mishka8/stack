# ОТЧЁТ
## Постановка задачи - Разбор алгебраического выражения с помощью стека
> [!NOTE]
> Множества
> 1. символов 'a'  - 'z', '0' - '9';
> 2. операций '+','-','*','/'  '(',')';

### РЕШЕНИЕ И АЛГОРИТМ
Так как наша задача проверить правильное ли выражение или нет, 
мы не учитываем приоритет операций.
Первым делом мы проверяем скобки правильно ли они раставлены или нет.
После мы опускаем скобки 
выражение без скобок мы проверяем с помощью "троек" 

## СТЕК
> [!NOTE]
> Стек (от англ. stack — стопка) — структура данных, представляющая собой упорядоченный набор элементов, в которой добавление новых элементов и удаление существующих производится с одного конца, называемого вершиной стека.
```C
struct nodelist
{
    char inf;//данные 
    struct nodelist *next;//указатель на следующий элемент 
};
```

```C
struct Steklist
{
    struct nodelist *top;//верхушка
    int size;// количество элементов 
};
```
```C
typedef struct nodelist node;
typedef struct Steklist stek;
```
данные две строчки позволяют нам сделать новый тип данных в программе чтобы удобнее было писать код

### ФУНКЦИИ ДЛЯ РАБОТЫ СО СТЕКОМ

> [!NOTE]
> 1. push или положить в вершину
> 2. pop или вытащить из верщины
> 3. show top или показать вершину стека
> 4. print stek вывод стека
> 5. is empty проверка на пустоту
> 6. del stek удаление стека полностью

1. push или положить в вершину
```C
bool push(stek *st, char val)//входные данные стек и данные которые надо положить в стек
{
    if(st)//проверка что данные коректны
    {
        node *new_el = (node*) malloc(sizeof(node));// создаём элемент 
        if(new_el)// проверка что элемент создан
        {
            new_el -> inf = val;
            new_el -> next = NULL;
            if(st -> top == NULL) // если стек пуст 
            {
                st -> top = new_el; // новый элемент теперь вершина 
            }
            else
            {
                new_el -> next = st -> top; // проводим связи
                st -> top = new_el; // и объявляем неовый элемент вершиной стека
            }
            st -> size++; // увеличиваем количество значчений
            return true; // возвращаем true если функция отработала правильно 
        }
    }
    return false; //иначе возвращаем false
}
```
2. pop или вытащить из верщины
```C
char pop(stek *st)//входные данные стек 
{
    if(st)//проверка данных
    {
        if(st -> top)// проверка пуст ли стек или нет  
        {
            char elem = st -> top -> inf;// запоминаем элемент 
            node *ptrIx = st -> top;// делаем указатель на вершину стека 
            st -> top = st -> top -> next;// сдвигаем вершину стека 
            st -> size--;// уменьшаем размер 
            free(ptrIx);// удалем элемент 
            return elem;// возвращем элемент котрый запомнили 
        }
    }
    return 0;// иначе возвращаем ноль
}
```
3. show top или показать вершину стека
```C
bool ShowTop(stek *st, char *val)// входные данные стек и адрес куда положить данные из верха стека
{
    bool ans = false;// 
    if(st && val)// проверка данных 
    {
        if(st -> top)// если есть вершина стека
        {
            *val = st -> top -> inf;// кладём значение по адресу
            ans = true;// меняем ans на true
        }
    }
    return ans;// возвращаем ans
}
```
4. print stek вывод стека
```C
void print_stack(stek st)//входные данные стек
{
    if(st.top == NULL)// проверка если стека нет то стек пустой
        printf("Stack is empty!\n");
    node *current = st.top;// указатель для навигации по элементам 
    while(current)// 
    {
        printf("%c\n", current -> inf);  //вывод 
        current = current -> next;// указываем на следующий элемент 
    }
}
```
5. is empty проверка на пустоту
```C
bool isEmpty(stek st)//входные данные стек
{
    if(st.top == NULL)// если стек пустой 
        return true;// возвращаем true
    return false;// иначе возвращаем false
}
```

6. del stek удаление стека полностью
```C
void delStek(stek *st)//входные данные стек
{
    if(st)// проверка данных
    {
        if(st -> top)// проверка что есть вершина стека
        {
            node *ptr = st -> top;// указатель на вершину
            node *ptrIx = NULL;// указатель для удаления данных
            while(ptr)// 
            {
                ptrIx = ptr;// 
                ptr = ptr -> next;// уставнавливаем указатель на следующий элемент
                st -> size--;// уменьшаем размер
                free(ptrIx);// очищаем элемент
            }
            st -> top = NULL;//вершина теперь NULL
        }
    }
}
```
## ГЛАВНАЯ ФУНКЦИЯ ПРОВЕРКИ ВЫРАЖЕНИЯ

>[!IMPORTANT]
> 1. Проверка скобок так, как нам не важене приоритет операций, то нам достаточно проверять скобки и опускать их из выражения
> 2. далее работа с самим выражением 
> 3. Полностью помещаем выражение в стек
> 4.проверка тройками и замена тройки на один символ
```C
push(&st, 'v');
```

Сама функция: 
```C
bool check_expression(char *str)//входные данные строка 
{
    if(str == NULL)// проверка данных  
        return false;// возвращаем false
    if(strlen(str) == 0)// если строка пустая
        return false;//

    stek st = {NULL, 0};// стек для выражения 
    stek staples = {NULL, 0};// стек для скобок 
    bool flag = true;// флаг равен истине
    for(int i = 0; str[i] != '\0'; i++)// цикл по всей строке 
    {
        if(str[i] == '(')// если мы находим открывающуюся скобку
        {
            flag = true;// флаг равен истине
            if(('a' <= str[i + 1] && str[i + 1] <= 'z') || ('0' <= str[i + 1] && str[i + 1] <= '9') || str[i + 1] == '-' || str[i + 1] == '+' || str[i + 1] == '(')// проверка  что после первой скобки есть ещё символы чтобы скобки не были пустые
            {
                flag = true;// флаг равен истине 
                push(&staples, '(');// заносим скобку в стек
            }
            else
            {
                flag = false;// иначе флаг равен лжи
                return false;// возвращаем false и выходим из функции 
            }
        }
        else if(str[i] == ')')// если мы находим закрывающую скобку
        {
            if(isEmpty(staples))// проверка если стек со скобками пустой
                return false;// возвращаем false

                pop(&staples);// вытаскиваем скобку которую помещали в стек 
        }
        else if(str[i] != ' ')// для унарного минуса и плюса
        {
            if(flag &&  (str[i] == '-' || str[i] == '+'))// проверка что строка
            {
                //делаем из выражения (-2) = 0 - 2 или (+2) = 0 + 2
                push(&st, '0');//помещяем ноль в стек 
                push(&st, str[i]);// помещяем  символ в стек 
            }
            else
                push(&st, str[i]);// иначе просто помещаем символ в стек 

            flag = false;// делаем флаг равным лжи
        }

    }
    print_stack(st);// выводим наше выражение в стеке (это необязательно)

    if(isEmpty(staples) == false)//проверка если стек со скобками не пустой 
        return false;// возвращаем false выходим из функции 

    bool flag1 = true;// делаем ещё один флаг

    while(flag1)// цикл пока флаг true
    {
        stek triple = {NULL, 0};// стек для "троек"

        for(int i = 0; i < 3; i++)//цикл по тройкам 
        {
            char tmp = pop(&st);// вытаскиваем из стека с выражением 
            push(&triple, tmp);// помещаем в стек с тройками 
        }
        int pos = 0;// для проверки позиции символа 
        bool flag_grammar = true;// флаг для грамматики  
        while(isEmpty(triple) == false)// пока наша тройка лежит в стеке
        {
            char symbol = pop(&triple);// вытаскиваем символ из стека с тройками 
            if(('a' <= symbol && symbol <= 'z') || ('0' <= symbol && symbol <= '9'))// проверка что символ правильный 
                if(pos % 2 == 1)// проверка позиции символа если позиция не та то
                    flag_grammar = false;// флаг граматики false
            if(symbol == '+' || symbol == '-' || symbol == '*' || symbol == '/')// проверка мат операции 
                if(pos % 2 == 0)// проверка позиции если позиция символа не та то 
                    flag_grammar = false;// флаг граматики false

            pos++;// прибавляем позицию

        }
        if(flag_grammar)//если флаг граматики true 
        {
            push(&st, 'v');// в стек где лежит выражение заносим новый символ 
        }
        else
            return false;// иначе выходим с функции 

        if(st.size == 1)// если размер стека с выражением равен единице   
            flag1 = false;//выходим из цикла с помощью флага

    }
    return true;//возвращаем true функция отработала 

}
```















